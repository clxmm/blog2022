---
title: 18整合Cache-缓存模型JSR107规范
toc: true
tags: springboot
categories: 
    - [java]
    - [springboot]
---

告别了 ElasticSearch 之后，下面我们要接触的一个非常常见的场景整合：缓存。缓存在项目中的使用有多广多频繁，想必不用我说各位也都非常清楚，那些需要频繁访问的数据，或者加载成本比较高的数据，都可以放到缓存中进行快速访问和获取。

在学习 SpringBoot 整合缓存的方式之前，本章我们先对缓存的一些前置知识进行回顾和基础增强。

## 1. 缓存与缓存模型

<!--more-->

首先我们先来回顾下缓存相关的理论知识。

#### 1.1 缓存

缓存本身与数据库并没有本质上的区别，它们都是用来存储数据的介质，只不过缓存相比起数据库而言，它的访问速度更快，且存储的数据通常具有时效性。

缓存通常用于频繁需要读取，或者检索 / 计算成本比较高的数据存储，譬如我们有一个非常复杂的 SQL 查询（假设用于首页的 dashboard 图表展示），但是这个数据的访问频率还特别高，这个时候就可以考虑将查询的数据放入缓存中，等到第二次再访问时，得益于缓存的高速特性，应用程序就可以快速地从缓存中读取该数据并返回，从而实现快速响应。

另外，缓存还有一个很有用的功能：临时数据的存储。有些数据仅仅是用来临时存放（如手机验证码），这样放到传统的关系型数据库中虽说可以，但处理起来略麻烦，此时缓存就又可以上场了。缓存通常都有一个特性：存储的数据可以有时效性，当效期过后，数据会被缓存丢弃，以这种方式既可以实现临时数据的存储，又可以在数据失效后自动被舍弃。

#### 1.2 缓存的设计

根据存储数据的方式，常见的数据存储类型有传统二维关系表型（即传统的关系型数据库）、json 数据型（文档型缓存，代表产品 MongoDB ）、key-value 型（键值对缓存，代表产品 Redis 、Memcache ）等等，而缓存讲究的通常是根据一个指定的数据，来获取对应的数据，所以用 key-value 键值对缓存是最合适的。之前我们接触的 SpringDataRedis 对应的 Redis 就是非常经典的键值对型缓存中间件。

参照 Redis 中的数据类型设计，我们也可以构思一下，一个缓存模型大概应该长什么样子。

Redis 中包含的数据类型有简单的 key-value ，还有一种很重要的模型：Hash ，即 key-key-value ，这种两个 key 确定一个 value 的设计很有趣，我们可以用简单的一张图解释：

![](/img/202302/18cache.png)

每个大的方框中又包含若干个小的键值对，这就是经典的 key-key-value 模型。

为什么要拿出这个模型来单独解释呢？这就需要各位小伙伴来思考一个问题：**如果单纯的 key-value 键值对太多的话，那么管理这些缓存数据是不是就会变得很麻烦？如果能用一个更大的“范围”来分门别类的划分这些缓存数据，那是不是维护起来会更容易呢？**

于是在早期，一个 JSR 规范就诞生了，它就是有关 Java 中的缓存模型规范：**JSR-107** 规范。

## 2. JSR-107

JSR-107 规范中针对缓存的模型，最终抽象为 5 个接口，一一来看。

#### 2.1 CachingProvider

`CachingProvider` ，意为“缓存的提供者”，它是整个 JSR-107 规范中最顶层的接口，它可以生产多个 `CacheManager` 。正常来讲，一个应用在运行期间可以产生多个 `CachingProvider` ，但通常应用中只会有一个，除非有特殊的多场景需求，才可能会创建多个 `CachingProvider` 。

#### 2.2 CacheManager

`CacheManager` ，意为“缓存的管理者”，它由上面的 `CachingProvider` 产生，且具备管理具体 `Cache` 缓存对象的能力。`CacheManager` 中定义了创建、配置、获取、管理和控制 `Cache` 对象的方法，这些 `Cache` 都会在 `CacheManager` 的管理范围之内。

另外，由于 `CacheManager` 是由 `CachingProvider` 产生的，所以一个 `CacheManager` 只会被一个 `CachingProvider` 所拥有。

#### 2.3 Cache

`Cache` 是具体的缓存器，它的设计非常类似于我们熟悉的 `Map` ，也就是键值对存储集合。`Cache` 由 `CacheManager` 生产，所以一个 `Cache` 仅能被一个 `CacheManager` 所持有。

#### 2.4 Entry

`Entry` ，这个概念我们更熟悉了，它就是类似于 `Map` 中的那个内部类 `Entry` ，从设计意义上讲是一样的，只不过在 JSR-107 规范中的 `Entry` 是归属于 `Cache` 接口的。

#### 2.5 Expiry

从上面的概念中我们已经知道，缓存是可以有过期时间的，所以 JSR-107 规范中的最后一个接口就是专门给 `Entry` 配置过期时间的 `Expiry` 。JSR-107 缓存规范中指明，每一个存储在 `Cache` 中的数据都是有有效期的，一旦超过这个时间，那么该数据就会被认定为“过期”，数据也就相当于被删除了。

`CachingProvider` 负责管理所有的 `CacheManager` ，在一个项目中可以存在一个也可以是多个；一个 `CachingProvider` 本身可以创建多个 `CacheManager` ，而 `CacheManager` 又可以创建多个 `Cache` （即最终存储缓存数据的容器），一个 `Cache` 中保存了多个键值对，也就是 `Entry` ，每个 `Entry` 上都绑定了对应的过期时间 `Expiry` 。

【本节内容我们简单回顾了缓存的设计，以及 JSR-107 规范中缓存的抽象。SpringCache 的设计参考了 JSR-107 规范，且它包容了很多缓存的实现，下一章的内容我们就重点了解它。】

