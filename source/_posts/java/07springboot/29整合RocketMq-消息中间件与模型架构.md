---
title: 29整合RocketMq-消息中间件与模型架构
toc: true
tags: springboot
categories: 
    - [java]
    - [springboot]
---

上一个部分我们用 5 章内容讲解了 SpringSecurity 这个安全访问控制框架。下面的几章中我们来讲解另一个项目中经常会使用的组件：**消息中间件**。

消息中间件也叫消息队列，顾名思义它是一个用于传输消息的队列模型，在网络环境和应用架构中被广泛用于同步 / 异步的数据传输、消息传递等工作。本章我们先整体了解 / 回顾一下消息中间件的设计，相关规范，以及模型架构。

## 1. MQ的应用场景

---

**消息中间件 Message Queue** ，简称 MQ ，本质是一种符合 FIFO 先进先出的数据结构。由于消息中间件本身是一个独立的组件，所以它可以用于一些业务场景中。

### 1.1 功能解耦

举一个很常见的业务场景吧，创建订单扣库存发消息：当订单创建成功后，应同步扣减库存，以及推送用户消息。

<!--more-->

如果把这个业务放在一个单体应用中，那么这三者是耦合到一个业务代码中的；而引入消息中间件后，这三者业务就可以拆分为 3 个服务了。当订单创建成功后，订单服务可以向消息中间件发送一个“包含订单和明细数据”的消息，由库存服务和消息服务监听该消息，从而完成它们各自负责的扣减库存和消息推送工作。

![](./img/202303/29mq1.png)

### 1.2 数据传递

当两个服务需要传递数据的时候，通常有以下几种方式：

- 借助中间库传递
- 借助开放式接口传递
- 借助消息中间件传递

消息中间件作为数据传递的一种实现方式，它完全可以通过消息作为载体，将数据从生产方推送到消费方。此外，依托消息中间件的一些特殊特性，可以实现消息的可靠投递，也就意味着数据可以必达消费方。

### 1.3 流量削峰

正常情况下我们在部署应用时，都是以正常的访问流量为基准考虑的（部署过多的应用实例也只是徒增功耗 + 浪费资源），但是在一些特殊场景中势必会出现访问流量激增的情况（比如电商中的秒杀场景），瞬间的流量涌入应用很有可能把系统、服务器压垮，造成生产环境的事故。

消息中间件的引入可以缓解这一问题，当客户端请求抵达服务器时，我们可以先将这些请求缓存到消息中间件中，并将这些请求均匀的输送给应用，这样既可以保证请求都能被处理，同时还不至于把应用服务器压垮。

![](./img/202303/29mq2.png)

### 1.4 异步任务

日常的项目开发中不可避免的会出现一些耗时长的业务，如果使用传统的同步阻塞式处理，则客户端需要长时间等待响应，用户体验不好。为此我们可以使用异步任务处理，而消息中间件同样能作为异步任务的任务传递工具，在分布式项目中如果一个服务需要调用另一个服务，执行一个耗时长的任务，此时我们可以改变思路，由任务调用方向消息中间件发送一个异步任务执行的消息，由被调用的服务接收该消息并执行。以此法改变后，客户端不需要等待服务执行完毕，而是消息推送到 MQ 后就已经可以响应成功，而异步任务最终调用是否成功，由被调用的服务负责实现通知 / 回推。

## 2. 消息模型的架构设计

---

下面我们聊一下有关消息中间件的模型。

一个消息中间件的模型通常包含两个最核心的部分： **消息代理 Message Broker** 和 **消息发送的目的地 Destination** 。当消息从生产者发送给消息中间件后，队列的内部会由消息代理接管这个消息，并由消息代理将这些消息推送到指定的目的地。

消息如何推送到目的地呢？一般通过两种方式：点对点的**队列**通信（queue），和一对多的发布订阅**主题**通信（topic）。

- 点对点：消息生产者将消息推送给 MQ 的一个队列中，消息接收者直接从队列中取出该消息进行消费，消息被读取后即被移除队列；
  - 点对点的模型最大的特点：消息只有唯一的生产者和接收者（注意这里的接收者并不是指应用实例，而是一个应用，一个应用可能有多个实例组成集群）
- 发布订阅：消息生产者将消息推送给 MQ 的一个 topic 后，多个消息接收者（订阅方）监听这个 topic ，每当消息到达这个 topic 后，所有的消息接收方都能收到消息；
  - 发布订阅的模型最大的特点：多个消息接收者，且每个接收者都会收到相同的消息

![](./img/202303/29mq3.png)

## 3. JMS&AMQP

在 MQ 中有两个非常经典的规范，虽然 RocketMQ 不属于这两个规范之一，不过了解一下这两个规范也可以更好地理解 RocketMQ 。

Java Message Service ，Java 消息服务，它是 Java 语言中定义的一个消息规范，它基于 JVM 的消息代理而形成规范。由于是 Java 语言中定义的规范，所以它只能在 Java 语言内部使用，无法跨语言和跨平台。

JMS 规范定义了两种消息模型，就是上面所说的点对点（peer 2-peer）和发布订阅（pub/sub），支持发送的消息类型很多，包括 Text 、Map 、Bytes 、Stream 、ObjectMessage 。

简单的总结下来，JMS 规范是在 Java 层面的消息规范标准，只要是 Java 语言编写的项目都可以利用 JMS 规范集成消息体系，与支持 JMS 协议的消息中间件进行交互。

ActiveMQ 是 JMS 规范的经典产品实现。

**AMQP 规范**

Advanced Message Queuing Protocol ，高级消息队列协议，本质上说它也是一个消息代理的规范，这个规范还天然兼容 JMS 规范。另外注意一点，AMQP 是一个设计在应用层协议的规范，所以它是不受语言和平台限制的，使用任意语言在任何平台上都可以使用。

AMQP 提供的消息模型更多，除了传统的点对点（direct exchange）和发布订阅（topic exchange）之外还有 fanout exchange 、headers exchange 、system exchange ，不过从本质上来说，后面的这 3 种还是发布订阅模型，只不过 AMQP 规范中对发布订阅的路由机制做了更详细的划分。

由于 AMQP 设计在应用层，不受任何语言限制，所以它只支持发送二进制消息，发送消息时需要先将消息序列化，接收消息时也需要反序列化。

RabbitMQ 是 AMQP 规范的经典产品实现。

## 4. 主流MQ对比

既然有上面成熟的规范实现的产品，那为什么我们还会选择 RocketMQ 呢？下面我们就来简单对比一下市面上主流的 4 款消息中间件。

| 对比维度   | **ActiveMQ** | RabbitMQ       | **RocketMQ**       | Kafka                |
| ---------- | ------------ | -------------- | ------------------ | -------------------- |
| 开发语言   | Java         | Erlang         | Java               | Scala                |
| 实现协议   | JMS          | AMQP           | /                  | /                    |
| 单机吞吐量 | 万级         | 万级           | 十万级             | 十万级               |
| 时效性     | 毫秒级       | 微秒级         | 毫秒级             | 毫秒级               |
| 高可用支持 | 主从架构     | 主从架构       | 分布式架构         | 分布式架构           |
| 一句话优点 | 成熟、文档多 | 并发高、延迟低 | 功能完善、扩展性高 | 吞吐量高，适合大数据 |

很明显，如果为了性能的话，选 RabbitMQ 是不二选择；为了功能强大，选 RocketMQ 就没错；如果只是为了高吞吐的话，那 Kafka 是首选。小册选择了使用功能最丰富强大的 RocketMQ 作为讲解的消息中间件。

【简单回顾了消息中间件之后，下一章我们就来实际上手一下 RocketMQ 的安装和使用】

