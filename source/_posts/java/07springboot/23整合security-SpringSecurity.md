---
title: 23整合security-SpringSecurity
toc: true
tags: springboot
categories: 
    - [java]
    - [springboot]
---

下一个我们要介绍的内容是与权限、安全框架有关。我们开发的几乎所有项目都离不开安全这个话题，或许是为了防止恶意操作，或许是防止数据泄露，更或许是防止服务器被攻击，我们都需要考虑项目的安全和防护。另外对于正常的用户使用而言，我们还需要为每个用户界定可访问、可操作的范围，并且能够正确识别不同的用户，这也是安全相关的课题。

下面的几章内容中，我们就来讲解 SpringBoot 与权限安全相关的整合方案 —— SpringSecurity 。

## 1. 认证&授权

---

首先我们先对认证、授权，以及它所属的安全领域有一个认识。先注意一点，这些概念都是在应用安全领域通用的，不是具体到某一个框架特有的。

<!--more-->

#### 1.1 认证

**Authentication 认证**，它指的是能够识别和验证一个用户信息是否合法，或者说是否具有系统中相符合的身份。

注意上面这句话其实并不完全准确，因为在不少大型项目或者具备上下游关系的项目中，它们通常会对接不同的第三方系统，这些第三方系统或多或少也要访问它们的系统，获取一些数据，亦或者进行一些数据传递，在这种情况下认证就不是识别用户的身份了，而是“第三方系统”。

所以严格的来讲，认证识别的其实是**主体 Object** （主体可以包含普通用户、设备、第三方应用等）。

#### 1.2 授权

**Authorization 授权**，它指的是能够验证某个已经认证通过的主体（用户），是否拥有访问某个系统资源的权限。

注意授权的概念中，核心讲的是校验，当一个主体认证通过后，是否能访问系统中的数据 / 菜单等（统称为资源），需要系统内部对这个主体的访问动作进行授权，即必须授予你访问的权限，你才能访问。而授予访问权限的动作就是授权，授权的实现方案其实就是权限校验——即校验你访问的资源是否合法。

通常来讲，授权的方式有如下几种：

- 基于角色的授权
- 基于用户的授权
- 基于组织 / 部门的授权
- 基于细颗粒度的接口 / 方法级别授权

#### 1.3 权限管理和RBAC模型

简单的说，权限管理就是系统内设置的安全规则或安全策略，在系统运行中，用户的认证和授权动作都必须围绕这套规则来进行。

通常来讲，一个经典的 RBAC 权限管理的模型包含 3 个核心实体：用户、角色、资源。下面我们也来简单聊一下 RBAC 的模型。

RBAC 本身是 Role-Based Access Control 的缩写，意为**基于角色的访问控制**。简单的说，这种访问控制的核心规则是在访问之前校验当前登录人是否拥有某个角色。比方说下面这张图，当一个客户端携带身份信息，发起一个“获取所有部门”的请求，而服务器中的安全访问控制设定的规则是，获取所有部门需要当前登录人拥有“管理员”的角色，如果没有该角色则会响应 403 权限不足。

![](/img/202302/24sb-security.png)

这个逻辑很好理解吧，但是我想请各位思考一个问题：如果回头这个“获取所有部门”的资源可访问规则变了（比方说人力资源经理也可以访问），那应当如何修改呢？

很明显，我们要改的是菱形判断框中的校验规则，由检查是否有“管理员”的角色改为是否拥有“管理员”或“人力资源经理”的角色。

但是这样写有什么问题呢？思考一下，如果后期需要管理的资源多起来之后，我们需要为每一个资源都设置可以访问的角色，如果某个资源的访问规则变更后，我们还需要手动修改校验规则，这样的模型在维护和扩展时会比较费劲。

那有没有优化空间呢？当然是有的，其实 RBAC 还有第二种解释：Resource-Based Access Control ，意为**基于资源的访问控制**。这种访问控制的核心规则是，在访问某个资源之前校验当前登录人是否有这个资源的访问权。还是上面那张图，如果改为基于资源的访问控制，则中间的菱形判断规则要改为“当前登录人是否拥有 xxx 资源的访问权”。

这样设计之后，在校验时仅需要判断当前登录人是否拥有某个权限即可，而用户拥有的权限是通过角色传递过来的，即一个用户拥有多个角色，一个角色包含多个权限。即便回头“获取所有部门”这个资源的可访问角色改为“管理员”和“人力资源经理”二选一，或者干脆改成只允许“人力资源经理”访问，再怎么改，咱们底层的判断规则是不需要变动的，只需要给用户分配不同的角色即可。

由此可见，**基于资源的访问控制**的模型更适合作为权限管理的模型实现。

## 2. SpringSecurity

---

下面我们简单了解一下 SpringSecurity 。

#### 2.1 SpringSecurity概述

SpringSecurity 本身是一个底层基于 SpringFramework 的安全访问控制框架，由于它的底层基于 SpringFramework ，所以它充分利用了 AOP 的特性来实现功能。SpringSecurity 的核心是一个 `Filter` 过滤器，通过对客户端的请求进行拦截，并根据权限管理的策略进行处理，就可以达到安全访问控制的效果。

#### 2.2 SpringSecurity的模块

SpringSecurity 的核心就是它本身，在历史的一些版本中，还曾经有过一个 SpringSecurityOAuth 的模块，不过后来已经被目前最新的 Spring Authorization Server 替代。

> 本小册中我们主要讲解的是 SpringSecurity 与 WebMvc 的应用整合，并不会涉及到 OAuth 和单点登录等场景。

在开始 SpringBoot 整合 SpringSecurity 之前，我们先简单了解一下 SpringSecurity 的基本架构，这对我们后面整合开发和原理探究都有很大的帮助。

#### 2.3 SpringSecurity的基本设计

在开始 SpringBoot 整合 SpringSecurity 之前，我们先简单了解一下 SpringSecurity 的基本架构，这对我们后面整合开发和原理探究都有很大的帮助。

由于 SpringSecurity 核心解决的问题就是安全访问的控制，那既然 SpringSecurity 是基于 `Filter` 机制来实现的控制，那我们可以先从它提供的 `Filter` 切入了解。

正常来讲，我们一个工程中可能会存在 0 到多个过滤器，它们的整体结构应该是这样的：

![](./img/202302/24sb-security1.png)

下面我们需要补充一个小知识点：原生的 `Filter` 是依托 Servlet 容器生命周期的，SpringFramework 为了让基于 Servlet 容器的 `Filter` 能够整合进 IOC 容器的生命周期，所以它扩展了一个 `DelegatingFilterProxy` 来做代理适配，当我们向 IOC 容器中注册一个 `DelegatingFilterProxy` 类型的过滤器，并指定它要代理的原始过滤器的 Bean 的名称，它就会在 IOC 容器初始化阶段，从 IOC 容器中找到指定的过滤器 Bean ，后续在触发过滤器的 `doFilter` 方法时，这个 `DelegatingFilterProxy` 会将过滤的逻辑转交给内部原始的 `Filter` 来实现。
可能到这里有小伙伴听着感觉很绕，折腾这么一顿，搞的这个 `DelegatingFilterProxy` 有什么作用呢？其实它的作用就是**使用代理的机制，将本来注册到 IOC 容器中的 `Filter` ，挂载到 Servlet 容器的应用上，这样就可以实现 IOC 容器中注册的 `Filter` 也能参与 `Servlet` 访问的过滤**。

回到正题，SpringSecurity 中整合到 `Filter` 过滤器链上的过滤器，其实就是一个 `DelegatingFilterProxy` 。所以加入 `DelegatingFilterProxy` 后的整体结构就应该变成这样：

![](../img/202302/24sb-security2.png)

那 SpringSecurity 整合进去的这个 `DelegatingFilterProxy` 具体代理的啥呢？很有趣，它代理的还是一个代理 `FilterChainProxy` （即 “代理了一个代理” ）。为什么会再套一层代理呢？是因为 SpringSecurity 的核心过滤器内部，是由一组分工明确的 `Filter` 组成的一个过滤器链。当明确了 SpringSecurity 的核心过滤器的地位时，整体结构就变成了下图的样子：

![](../img/202302/24sb-security3.png)

到这里其实就算可以了，毕竟我们还没开始用呢！到目前为止只需要各位知道，SpringSecurity 的内部核心工作的组件是一个 `FilterChainProxy` ，它内部包含了一组过滤器组成的 `SecurityFilterChain` 过滤器链。

【简单了解安全访问控制的相关核心概念，以及 SpringSecurity 的基本设计后，下面我们就来实际的整合一下基于 WebMvc 的 SpringBoot 项目】

