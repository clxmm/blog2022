---
title: 14整合ElasticSearch
toc: true
tags: springboot
categories: 
    - [java]
    - [springboot]
---

对于关系型数据库而言，在日常的业务场景当中，如果遇到复杂查询，或者频率非常高的查询时，其性能很容易成为整个应用运行的瓶颈。我们都知道，关系型数据库更擅长的是数据持久化存储，在面对复杂查询（多表关联、嵌套子查询）时性能会有所下降，在请求查询的高频率场景下也会出现性能不足的情况。针对以上所述的两种场景，在大型项目开发中可以引入搜索引擎，将这部分搜索的数据放入具备高性能特点的搜索引擎中，让它代替传统的关系型数据库来完成查询搜索工作，接下来的几章中，我们就来使用 SpringBoot 整合一下目前最流行的搜索引擎框架 —— ElasticSearch 。

## 1. 搜索引擎

首先我们先来了解和回顾下有关搜索引擎的概念。

#### 1.1 如何理解搜索引擎

搜索引擎，它本身是根据用户提供的信息，通过一定的搜索算法和策略，将数据从特定的数据源中检索并反馈的技术。

搜索引擎本身是基于全文检索的，它的核心工作流程是将原始数据存入原始数据库，之后进行数据的预处理和索引构建，等到用户发起搜索请求时，利用其搜索算法将数据从原始数据库中提取出来，从而完成搜索工作。

#### 1.2 ElasticSearch与Solr

<!--more-->

对于 Java 生态来看，近 15 年流行的搜索引擎无非 ElasticSearch 与 Solr ，为什么我们选择了 ElasticSearch 呢？核心原因是目前使用的最广，热度也是最高的（自 2014 年后反超 Solr 后一骑绝尘），除此之外还有以下几个小因素：

-  安装难度成本：ElasticSearch 的安装相对于 Solr 而言更简单，配置也相对简单；
- 原始数据输入：ElasticSearch 支持的原始数据来源非常多，除了传统的文本、关系型数据库之外，MongoDB 、Redis 、消息中间件等都可以是 ElasticSearch 的原始数据来源；
- 可扩展与高可用：ElasticSearch 天然支持分布式，其内部有一个 Zen 组件，通过内部协调机制即可实现集群状态维护，而 Solr 需要借助 Zookeeper 完成分布式；
- 性能：ElasticSearch 的性能非常高，即便是数据量巨大的前提下，而 Solr 在面对海量数据时会力不从心。

基于以上指标的对比，我们果断选择 ElasticSearch 作为搜索引擎的解决方案。

## 2. ElasticSearch

首先我们先得知道一点：ElasticSearch 也好，Solr 也好，其底层都是运用了 Apache 的搜索工具 Lucene ，所以首先我们先来回顾下 Lucene 是什么。

#### 2.1 Lucene

Lucene 本身就是一个搜索工具，说白了它的表现形式就是一组 jar 包。对于 Lucene 而言，它的工作流程大致可以分为 4 个环节：

1. 获取原始数据（原始文档），并构建文档对象；
2. 根据读取到的文档，进行文档的分析（该步骤包含文本的分词动作）；
3. 对文档分析完毕后，会根据分析的结果创建用于检索的索引库；
   - 该环节产生的索引结构是**倒排索引结构**，简单来讲倒排索引结构是根据内容（一个简短的词语）找文档，它的词语库规模相对小，但它可以映射到其所在的文档中，这种结构很适合全文检索；
4. 有了索引库后，等到需要检索时，就可以通过查询索引，进而获得原始的数据（或文档）。

#### 2.2 ElasticSearch概述

下面该说 ElasticSearch 了。ElasticSearch 是基于 Lucene 的搜索引擎，注意 ElasticSearch 不再是一个工具库或者一组 jar 包，而是一个正儿八经的搜索**服务器**，具备提供服务的能力！

ElasticSearch 原生支持分布式，其扩展性也很强，所以在面对海量数据时通过部署 ElasticSearch 集群也可以很好地应对。

ElasticSearch 可以处理的文档很多，除了用于应用数据的搜索之外，它还跟 Kibana 、Logstash 共同组合为日志收集和分析解决方案 “ELK” 。

ElasticSearch 提供服务的方式是通过暴露 http 服务，通过调用 RESTful 的 API 就可以实现对其操作，所以它才可以被称为搜索服务器。

#### 2.3 ElasticSearch的使用场景

ElasticSearch 的优势是检索速度和高扩展性，所以它更适合处理以下工作：

- 应用程序的数据搜索
- 网站信息和内容检索
- 日志处理和检索分析
- 基础设施的指标和容器监测、分析
- 地理数据的分析和可视化

#### 2.4 ElasticSearch的基础概念

接下来我们回顾一下 ElasticSearch 的一些基本概念，只有把这些基本概念理解清楚后，后面在整合和使用 ElasticSearch 时才会更加顺利。

##### 2.4.1 index 索引

索引这个词，既可以是动词，也可以是名词。

作为名词来看，索引是一个类似于传统关系型数据库中的 database 数据库，也类似于 MongoDB 中的数据库，它指的是存储一系列数据的容器。

作为动词来看，索引是将一些数据进行拆解、映射的动作，它类似于传统关系型数据库的 insert 操作，索引 (v.) 这个动作实际是在创建索引 (n.) 。

##### 2.4.2 type 类型

在一个索引中，其内部可能包含一个或多个数据类型，也就是所谓的 type ，它类似于传统关系型数据库的 table 表，也类似于 MongoDB 中的集合。

##### 2.4.3 document 文档

document 文档，可以简单类比于 MongoDB 中集合内保存的一条条文档，也就类似于关系型数据库中一张表中的一条条数据。

所以根据上述的三个概念，可以有如下的对比图。

![](./img/202301/14es.png)

#### 2.5 倒排索引结构

本章的最后，我们展开回顾一下倒排索引这个结构的设计和特征。倒排索引的结构为什么效率快呢？我们回顾一下这个结构的设计就一目了然。

假设我们有如下的原始数据：

1. 自动装配
2. 配置类
3. 自动配置类
4. 装配核心组件
5. 组件装配

将这些数据输入搜索引擎时，搜索引擎首先会将这些原始数据进行分词，分词后的数据会变成如下形式：

1. 自动装配 → 自动 + 装配
2. 配置类 → 配置 + 类
3. 自动配置类 → 自动 + 配置 + 类
4. 装配核心组件 → 装配 + 核心 + 组件
5. 组件装配 → 组件 + 装配

对这些分词后的数据进行汇总，会形成如下的一张倒排索引表：

| 索引词 | 存在的原始数据位置 |
| ------ | ------------------ |
| 自动   | 1,3                |
| 装配   | 1,4,5              |
| 配置   | 2,3                |
| 类     | 2,3                |
| 组件   | 4,5                |
| 核心   | 4                  |

 倒排索引表的设计很巧妙，它将分词后的一个个词都聚合起来，为它们标记了包含这个词在原始数据的位置，这样就意味着后续再搜索时，输入的索引词会从倒排索引表中找出，并关联查询出对应的原始数据。

举个例子：

- 当我们搜索 “组件” 时，匹配发现 4 和 5 都有“组件” 一词，所以就可以搜索出两条数据；
- 搜索 “组件自动装配” 时，先将被搜索词进行分词，拆解得 “组件 + 自动 + 装配” ，从倒排索引表中匹配发现 1 3 4 5 都有匹配，但 1 和 5 的匹配程度最高，所以 1 和 5 会被优先展示，3 和 4 的展示排序会靠后。

正是因为有这种倒排索引的设计，使得 ElasticSearch 的检索效率很快，从而实现高效的搜索工作。

【简单回顾了 ElasticSearch 和与其相关的基本概念之后，下一章我们先来安装 ElasticSearch ，并先熟悉 ElasticSearch 的操作和使用】







 



























