---
title: 18分布式id
toc: true
tags: springboot
categories: 
    - [java]
    - [concurrence]
---

在分布式服务中，各种复杂的业务场景需要有一个用于做唯一标识的 id，例如订单业务、支付流水、聊天通信等业务场景。尤其是在分库分表场景中，分布式 id 生成器的使用频率更高。因此分布式 id 组件的设计应该要能支持以下几个特性：

- **全局唯一特性**
- **组件递增特性**
  - 可以是每个 id 都具有递增的特性，也可以是支持区间段内具备递增的特性。
- **安全性**
  - 有些重要的 id ，如果无意中暴露在了外网环境中，且没有做过安全防范，这其实是一件非常危险的事情。例如说，订单的 id 如果是由日期加订单数目的格式生成的话，如 2020111100001 表示 2020 年 11 月 11 日的第一笔订单，那么这样的数据就很容易被竞品对手获取到该公司的数据信息，从而产生数据安全漏洞的问题
- **高 qps**
  - 在分布式集群中，id 生成器的调用其实是属于高并发请求，因此在设计的时候，对于性能的要求会比较高。 
- **高可用**
  - 由于分布式 id 生成器是一个需要支持多个服务调用方共同使用的公共服务，一旦出现崩溃后果不堪设想，可能会导致大面积的业务线崩塌，所以在高可用方面，尤其需要慎重考虑。

<!--more-->

## 1.业界常见的分布式 id 生成方案比对

### 1.uuid

Java 程序中实现 uuid 的代码：

```java
String result = UUID.randomUUID().toString();
System.out.println(result);
```

生成的格式如下所示：

```
b0b2197d-bc8c-4fab-ad73-2b54e11b0869
```

uuid 的格式其实是会被 - 符号划分为五个模块，主要是 8-4-4-4-12 个字符拼接而成的一段字符串。采用这类 id 生成的数据，其实会存在一些安全隐患和性能问题。

当使用 uuid 生成的字符串作为 MySQL 索引时，在有大量数据并发写入时，会导致 b+ 树的叶子结点裂变频率加大，在裂变重组b+树叶子结点时，需要进行对节点数据的逐个字符的比对，其性能损耗也较高，应该抛弃该方案。

另外在早期版本的 uuid 中，是基于机器的 MAC 地址生成的。基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，著名的梅丽莎病毒就是利用了这个漏洞而出名的。

### 2.**雪花算法**

SnowFlake 是 Twitter 公司采用的一种算法，目的是在分布式系统中产生全局唯一且趋势递增的 ID。

![](./img/202303/thread18-1.png)

这里我稍微解释一下雪花算法的含义：

第一位通常是 0，没有特殊使用含义，因为 1 通常表示为补码。中间的 41 位是用于存储时间，41 位的长度足够容纳 69 年左右的时长。接下来的 10 位用于标示机器自身的 id，从而表示不同机器自身 id 的不同。

最后 12 位用于表示某一毫秒内的序列号，12位（bit）可以表示的最大正整数是 4096-1=4095，所以也就是说，一毫秒内可以同时生成 4095 个 id。

雪花算法生成的 id 中，时间戳位置和序列号位置还不能随意调整，因为要保证逐渐递增的特性。使用雪花算法生成 id 有好处也有不足之处，其好处有：**能够保证递增的特性，id 具有明确的含义，易懂**。不足之处为：**对于机器自身的系统时间有所依赖，一旦机器的系统时间发生了变化，在高并发环境下就有可能会有重复 id 生成的风险。**

前边我们所介绍的这些 id 生成方式都是与业务无关联性的，但有些场景是需要在 id 中注入些许业务信息的，例如在生成 id 时，加入一些包含业务含义的前缀。之前在工作中就有遇到过类似的设计，例如短信 id 和奖券 id：

```
sms_108678123
coupon_12908123
```

不过这种 id 前缀的设计应该要结合具体的业务场景来定。

### 3.MongoDB 的主键 id 设计思路

其实在 MongoDB 里，也有往主键 id 中注入一些“基因”要素点的这类思路：

在 MondoDB 中，它的主键 id 叫做 _id，其底层的存储结果是采用了 objectid 对象，在这个 objectid 里，包含了时间戳、宿主机的 ip、进程号码、自增号数值。 

 在对这几种方案进行了调研之后，我们可以开始来着手实现一套分布式 id 生成器组件。

## 2.**自研主要设计思路**

MySQL 配置分布式id的生成规则，负责 id 生成服务应用在启动的时候，将 id 生成规则从数据库拉取到本地，然后在本地缓存中提前生成一段 id 集合，后续请求直接从本地服务中提取即可。支持集群配置 id 生成器，能够支持高 qps 访问和较好的扩容性。

![](./img/202303/thread18-2.png)

配置表如下图所示：

![](./img/202303/thread18-3.png)

建表 sql：

```sql
CREATE TABLE `t_id_builder_config` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '描述',
  `init_num` bigint(13) DEFAULT NULL COMMENT 'id起步值',
  `next_threshold` bigint(20) DEFAULT NULL COMMENT '当前id所在阶段的阈值',
  `current_start` bigint(20) DEFAULT NULL COMMENT '当前id所在阶段的开始值',
  `step` int(11) DEFAULT NULL COMMENT 'id递增区间',
  `id_prefix` varchar(60) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '业务前缀码，如果没有则返回时不携带',
  `version` int(11) NOT NULL DEFAULT '0' COMMENT '乐观锁版本号',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

这里我对这张表的各个重要字段做些简单的介绍：

- **init_num 字段** 是指id要从多少开始计算，这个和具体的业务场景有关，例如用户 id 的起步计算值就是一个不固定的数字。
- **next_threshold 字段** 这个字段表示了当前各台 id 生成服务中，本地记录的最大 id 段的下一次更新值。
- **current_start 字段** 这个字段表示了当前各台 id 生成服务中，本地记录的最大 id 段的开始值。
- **step 字段** 代表了每个 id 生成器在本地缓存 id 的数量是多少。
- **id_prefix 字段** 是一个业务前缀的表示功能，假设我们生成的 id 是希望有特殊的业务前缀的话，通过这个 id_prefix 来进行配置。

好了，现在我们已经将表给大概设计好了，但为了能够将这个组件给设计好，我们需要考虑一些极端情况下才会发生的问题，例如：

- **当同时有多个请求访问 MySQL 获取 id 配置的时候，该如何防止并发问题？**

首先，考虑到各个节点同时进行并发访问 MySQL 进行本地 id 段更新的概率会很低，所以在对行信息进行更新时加入了 version 版本号字段，用于防止更新覆盖的情况。即使说更新失败，也会有 cas 的方式进行重试，重试超过一定次数之后直接中断。

- **为何不引入 Redis 作为分布式锁，来防止并发修改数据库操作？**

  - 不希望将该组件变得过于繁杂，减少系统对于第三方的依赖性 。

- **假设本地 id 还没使用完，结果当前服务器宕机了，该如何预防？**

  - 每次服务启动都需要更新表的配置，拉去最新的一批 id 集合到本地，这样就不会出现和之前 id 冲突的问题了。

- **如何保证请求的高效性** **？**

  - 数据提前在本地缓存中生成，取数的时候直接从本地缓存中提取即可。

- **每次拉取到本地 id 段的大小该如何设计？**

  - 这里我们先将本地 id 段简称为 segment，对于 segment 大小的设计，需要结合具体业务场景的并发量来进行预估。来看下面的这个案例。

  

  我们的底层是计划设计一个定时任务去更新 segment 中的数据，这里我们假设更新的时间间隔为 X 秒。假设某时刻 segment 的数据达到了阈值，需要进行更新了，那么剩余的 segment 段至少是需要能够支撑超过 X 秒的，否则就会出现 id 生成失败的问题了。

  

## 3.**代码实现步骤**

好了，前边我们有了一个基本的设计思路之后，再进行代码的实现就会比较简单了，下边让我们来看看如何通过实战代码实现分布式 id 生成器。

**核心代码思路**

首先是一个对外调用的 id 生成器接口设计部分，这块的实现我是分成了两种类型：

- 生成唯一 id (连续性递增)；
- 包含业务前缀的自增 id (连续性递增)。

```java
public interface IdBuilderService {


    /**
     * 根据本地步长度来生成唯一id(区间性递增)
     *
     * @return
     */
    Long increaseSeqId(int code);


    /**
     * 根据本地步长度来生成唯一id(区间性递增)
     *
     * @return
     */
    String increaseSeqStrId(int code);

}
```

 